# Hello Triangle

In OpenGL everything is in 3D space, but the screen or window is a 2D array of pixels so a large part of OpenGL's work is about transforming all 3D coordinates to 2D pixels that fit on your screen. The process of transforming 3D coordinates to 2D pixels is managed by the graphics pipeline of OpenGL. The graphics pipeline can be divided into two large parts: the first transforms your 3D coordinates into 2D coordinates and the second part transforms the 2D coordinates into actual colored pixels. In this chapter we'll briefly discuss the graphics pipeline and how we can use it to our advantage to create fancy pixels.


The graphics pipeline takes as input a set of 3D coordinates and transforms these to colored 2D pixels on your screen. The graphics pipeline can be divided into several steps where each step requires the output of the previous step as its input. All of these steps are highly specialized (they have one specific function) and can easily be executed in parallel. Because of their parallel nature, graphics cards of today have thousands of small processing cores to quickly process your data within the graphics pipeline. The processing cores run small programs on the GPU for each step of the pipeline. These small programs are called shaders.

Some of these shaders are configurable by the developer which allows us to write our own shaders to replace the existing default shaders. This gives us much more fine-grained control over specific parts of the pipeline and because they run on the GPU, they can also save us valuable CPU time. Shaders are written in the OpenGL Shading Language (GLSL) and we'll delve more into that in the next chapter.

Below you'll find an abstract representation of all the stages of the graphics pipeline. Note that the blue sections represent sections where we can inject our own shaders.

  <img src="https://learnopengl.com/img/getting-started/pipeline.png" alt="Graphics pipline" />

As you can see, the graphics pipeline contains a large number of sections that each handle one specific part of converting your vertex data to a fully rendered pixel. We will briefly explain each part of the pipeline in a simplified way to give you a good overview of how the pipeline operates.

As input to the graphics pipeline we pass in a list of three 3D coordinates that should form a triangle in an array here called Vertex Data; this vertex data is a collection of vertices. A vertex is a collection of data per 3D coordinate. This vertex's data is represented using vertex attributes that can contain any data we'd like, but for simplicity's sake let's assume that each vertex consists of just a 3D position and some color value.

> [!NOTE]
> In order for OpenGL to know what to make of your collection of coordinates and color values OpenGL requires you to hint what kind of render types you want to form with the data. Do we want the data rendered as a collection of points, a collection of triangles or perhaps just one long line? Those hints are called primitives and are given to OpenGL while calling any of the drawing commands. Some of these hints are GL_POINTS, GL_TRIANGLES and GL_LINE_STRIP.

The first part of the pipeline is the vertex shader that takes as input a single vertex. The main purpose of the vertex shader is to transform 3D coordinates into different 3D coordinates (more on that later) and the vertex shader allows us to do some basic processing on the vertex attributes.

The output of the vertex shader stage is optionally passed to the geometry shader. The geometry shader takes as input a collection of vertices that form a primitive and has the ability to generate other shapes by emitting new vertices to form new (or other) primitive(s). In this example case, it generates a second triangle out of the given shape.

The primitive assembly stage takes as input all the vertices (or vertex if GL_POINTS is chosen) from the vertex (or geometry) shader that form one or more primitives and assembles all the point(s) in the primitive shape given; in this case two triangles.

The output of the primitive assembly stage is then passed on to the rasterization stage where it maps the resulting primitive(s) to the corresponding pixels on the final screen, resulting in fragments for the fragment shader to use. Before the fragment shaders run, clipping is performed. Clipping discards all fragments that are outside your view, increasing performance.


> [!NOTE]
> A fragment in OpenGL is all the data required for OpenGL to render a single pixel.

The main purpose of the fragment shader is to calculate the final color of a pixel and this is usually the stage where all the advanced OpenGL effects occur. Usually the fragment shader contains data about the 3D scene that it can use to calculate the final pixel color (like lights, shadows, color of the light and so on).

After all the corresponding color values have been determined, the final object will then pass through one more stage that we call the alpha test and blending stage. This stage checks the corresponding depth (and stencil) value (we'll get to those later) of the fragment and uses those to check if the resulting fragment is in front or behind other objects and should be discarded accordingly. The stage also checks for alpha values (alpha values define the opacity of an object) and blends the objects accordingly. So even if a pixel output color is calculated in the fragment shader, the final pixel color could still be something entirely different when rendering multiple triangles.

As you can see, the graphics pipeline is quite a complex whole and contains many configurable parts. However, for almost all the cases we only have to work with the vertex and fragment shader. The geometry shader is optional and usually left to its default shader. There is also the tessellation stage and transform feedback loop that we haven't depicted here, but that's something for later.

In modern OpenGL we are required to define at least a vertex and fragment shader of our own (there are no default vertex/fragment shaders on the GPU). For this reason it is often quite difficult to start learning modern OpenGL since a great deal of knowledge is required before being able to render your first triangle. Once you do get to finally render your triangle at the end of this chapter you will end up knowing a lot more about graphics programming.

# Vertex input
To start drawing something we have to first give OpenGL some input vertex data. OpenGL is a 3D graphics library so all coordinates that we specify in OpenGL are in 3D (x, y and z coordinate). OpenGL doesn't simply transform all your 3D coordinates to 2D pixels on your screen; OpenGL only processes 3D coordinates when they're in a specific range between -1.0 and 1.0 on all 3 axes (x, y and z). All coordinates within this so called normalized device coordinates range will end up visible on your screen (and all coordinates outside this region won't).

Because we want to render a single triangle we want to specify a total of three vertices with each vertex having a 3D position. We define them in normalized device coordinates (the visible region of OpenGL) in a float array:

```c++
float vertices[] = {
    -0.5f, -0.5f, 0.0f,
     0.5f, -0.5f, 0.0f,
     0.0f,  0.5f, 0.0f
};
```
Because OpenGL works in 3D space we render a 2D triangle with each vertex having a z coordinate of 0.0. This way the depth of the triangle remains the same making it look like it's 2D.

> [!NOTE]
> Normalized Device Coordinates (NDC)
Once your vertex coordinates have been processed in the vertex shader, they should be in normalized device coordinates which is a small space where the x, y and z values vary from -1.0 to 1.0. Any coordinates that fall outside this range will be discarded/clipped and won't be visible on your screen. Below you can see the triangle we specified within normalized device coordinates (ignoring the z axis):
>
> <img width="400" height="197" alt="image" src="https://github.com/user-attachments/assets/7d58f3fd-c705-4e56-a47e-9f3b4907d4cf" />
>
> Unlike usual screen coordinates the positive y-axis points in the up-direction and the (0,0) coordinates are at the center of the graph, instead of top-left. Eventually you want all the (transformed) coordinates to end up in this coordinate space, otherwise they won't be visible.
>
> Your NDC coordinates will then be transformed to screen-space coordinates via the viewport transform using the data you provided with glViewport. The resulting screen-space coordinates are then transformed to fragments as inputs to your fragment shader.



With the vertex data defined we'd like to send it as input to the first process of the graphics pipeline: the vertex shader. This is done by creating memory on the GPU where we store the vertex data, configure how OpenGL should interpret the memory and specify how to send the data to the graphics card. The vertex shader then processes as much vertices as we tell it to from its memory.

We manage this memory via so called vertex buffer objects (VBO) that can store a large number of vertices in the GPU's memory. The advantage of using those buffer objects is that we can send large batches of data all at once to the graphics card, and keep it there if there's enough memory left, without having to send data one vertex at a time. Sending data to the graphics card from the CPU is relatively slow, so wherever we can we try to send as much data as possible at once. Once the data is in the graphics card's memory the vertex shader has almost instant access to the vertices making it extremely fast

A vertex buffer object is our first occurrence of an OpenGL object as we've discussed in the OpenGL chapter. Just like any object in OpenGL, this buffer has a unique ID corresponding to that buffer, so we can generate one with a buffer ID using the glGenBuffers function:

```c++
unsigned int VBO;
glGenBuffers(1, &VBO);  
```
<h2>glGenBuffers</h2><h3>Buffers</h3><p><p>
  OpenGL's <code>glGenBuffers</code> function generates one or multiple buffer object(s). Buffer objects are instantiated behind the scenes and reference ID(s) are returned to the user to access those buffer objects. The type of the returned IDs is <code>GLuint</code>.
</p>
<p>
  The parameters of <code>glGenBuffers(GLsizei size, GLuint* buffers)</code> are as follows:
  <ul>
    <li><code>size</code>: defines how many buffer objects you would like to generate. <code>glGenBuffers</code> will return this many buffer IDs to the target <code>buffers</code> array.</li>
    <li><code>buffer</code> is a <code>GLuint</code> array where <code>glGenBuffers</code> will store its resulting buffer reference IDs.</li>
  </ul>
</p>

<h4>Example usage</h4>
<pre class="cpp"><code>
GLuint vbos[5]; // Can hold the id of 5 buffers
glGenBuffers(5, vbos); // Generates 5 buffer ids  
</code></pre>
</p>

OpenGL has many types of buffer objects and the buffer type of a vertex buffer object is GL_ARRAY_BUFFER. OpenGL allows us to bind to several buffers at once as long as they have a different buffer type. We can bind the newly created buffer to the GL_ARRAY_BUFFER target with the glBindBuffer function:

```c++
glBindBuffer(GL_ARRAY_BUFFER, VBO);  
```
<h2>glBindBuffer</h2><h3>Buffers</h3><p><p>
  The function <code>glBindBuffer</code> binds a buffer object to the current buffer type target. Only a single buffer can be bound for each buffer type. Binding <code>0</code> as a buffer resets the currently bound buffer to a <code>NULL</code>-like state.
</p>

<p>
  The parameters of <code>glBindBuffer(GLenum target, GLuint buffer)</code> are as follows:
  <ul>
    <li><code>target</code>: Specifies the target buffer object of which the most common are <code>GL_ARRAY_BUFFER</code> and <code>GL_ELEMENT_ARRAY_BUFFER</code>. </li>
    <li><code>buffer</code>: The buffer object's reference ID of the buffer you'd like to bind.</li>
  </ul>
</p>

<h4>Example usage</h4>
<pre class="cpp"><code>
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(data), data, GL_STATIC_DRAW);
glBindBuffer(GL_ARRAY_BUFFER, 0);
</code></pre></p>

From that point on any buffer calls we make (on the GL_ARRAY_BUFFER target) will be used to configure the currently bound buffer, which is VBO. Then we can make a call to the glBufferData function that copies the previously defined vertex data into the buffer's memory:

```c++
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
```
glBufferData is a function specifically targeted to copy user-defined data into the currently bound buffer. Its first argument is the type of the buffer we want to copy data into: the vertex buffer object currently bound to the GL_ARRAY_BUFFER target. The second argument specifies the size of the data (in bytes) we want to pass to the buffer; a simple sizeof of the vertex data suffices. The third parameter is the actual data we want to send.

The fourth parameter specifies how we want the graphics card to manage the given data. This can take 3 forms:
<ul>
    <li><var>GL_STREAM_DRAW</var>: the data is set only once and used by the GPU at most a few times.</li>
    <li><var>GL_STATIC_DRAW</var>: the data is set only once and used many times.</li>
    <li><var>GL_DYNAMIC_DRAW</var>: the data is changed a lot and used many times.</li>

  </ul>

The position data of the triangle does not change, is used a lot, and stays the same for every render call so its usage type should best be GL_STATIC_DRAW. If, for instance, one would have a buffer with data that is likely to change frequently, a usage type of GL_DYNAMIC_DRAW ensures the graphics card will place the data in memory that allows for faster writes.

As of now we stored the vertex data within memory on the graphics card as managed by a vertex buffer object named VBO. Next we want to create a vertex and fragment shader that actually processes this data, so let's start building those.


<h2>glBufferData</h2><h3>Buffers</h3><p><p>
  The function <code>glBufferData</code> allocates memory and stores data within the initialized memory in the currently bound buffer object. One of many functions to add/edit the buffer of a buffer object.
</p>

<p>
  The parameters of <code>glBufferData(GLenum mode, GLsizeiptr size, const GLvoid* data, GLenum usage)</code> are as follows:
  <ul>
    <li><code>mode</code>: Specifies the target buffer object of which the most common are <code>GL_ARRAY_BUFFER</code> and <code>GL_ELEMENT_ARRAY_BUFFER</code>.</li>
    <li><code>size</code>: Specifies the size in bytes of the buffer object's new data.</li>
    <li><code>data</code>: Specifies a pointer to data that will be copied into the buffer, or <code>NULL</code> if no data is to be copied (leaves allocted memory empty).</li>
    <li><code>usage</code>: Specifies the expected usage pattern of the data. Most common are <code>GL_STATIC_DRAW</code>, <code>GL_DYNAMIC_DRAW</code> and <code>GL_STREAM_DRAW</code>.</li>
  </ul>
</p>

<h4>Example usage</h4>
<pre class="cpp"><code>
GLfloat data[] = {
  0.1f, 0.2f, 0.3f, 0.4f ....
};
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(data), data, GL_STATIC_DRAW);
glBindBuffer(GL_ARRAY_BUFFER, 0);
</code></pre></p>


# Vertex shader

The vertex shader is one of the shaders that are programmable by people like us. Modern OpenGL requires that we at least set up a vertex and fragment shader if we want to do some rendering so we will briefly introduce shaders and configure two very simple shaders for drawing our first triangle. In the next chapter we'll discuss shaders in more detail.

The first thing we need to do is write the vertex shader in the shader language GLSL (OpenGL Shading Language) and then compile this shader so we can use it in our application. Below you'll find the source code of a very basic vertex shader in GLSL:

```GLSL
#version 330 core
layout (location = 0) in vec3 aPos;

void main()
{
    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);
}
```

As you can see, GLSL looks similar to C. Each shader begins with a declaration of its version. Since OpenGL 3.3 and higher the version numbers of GLSL match the version of OpenGL (GLSL version 420 corresponds to OpenGL version 4.2 for example). We also explicitly mention we're using core profile functionality.

Next we declare all the input vertex attributes in the vertex shader with the in keyword. Right now we only care about position data so we only need a single vertex attribute. GLSL has a vector datatype that contains 1 to 4 floats based on its postfix digit. Since each vertex has a 3D coordinate we create a vec3 input variable with the name aPos. We also specifically set the location of the input variable via layout (location = 0) and you'll later see that why we're going to need that location.

</br>
</br>

> [!NOTE]
> <note>
  <strong>Vector</strong><br>
  In graphics programming we use the mathematical concept of a vector quite often, since it neatly represents positions/directions in any space and has useful mathematical properties. A vector in GLSL has a maximum size of 4 and each of its values can be retrieved via <code>vec.x</code>, <code>vec.y</code>, <code>vec.z</code> and <code>vec.w</code> respectively where each of them represents a coordinate in space. Note that the <code>vec.w</code> component is not used as a position in space (we're dealing with 3D, not 4D) but is used for something called <def>perspective division</def>. We'll discuss vectors in much greater depth in a later chapter.
</note>

</br>
</br>

To set the output of the vertex shader we have to assign the position data to the predefined gl_Position variable which is a vec4 behind the scenes. At the end of the main function, whatever we set gl_Position to will be used as the output of the vertex shader. Since our input is a vector of size 3 we have to cast this to a vector of size 4. We can do this by inserting the vec3 values inside the constructor of vec4 and set its w component to 1.0f (we will explain why in a later chapter).

The current vertex shader is probably the most simple vertex shader we can imagine because we did no processing whatsoever on the input data and simply forwarded it to the shader's output. In real applications the input data is usually not already in normalized device coordinates so we first have to transform the input data to coordinates that fall within OpenGL's visible region.


# Compiling a shader
We take the source code for the vertex shader and store it in a const C string at the top of the code file for now:

```GLSL
const char *vertexShaderSource = "#version 330 core\n"
    "layout (location = 0) in vec3 aPos;\n"
    "void main()\n"
    "{\n"
    "   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
    "}\0";
```

In order for OpenGL to use the shader it has to dynamically compile it at run-time from its source code. The first thing we need to do is create a shader object, again referenced by an ID. So we store the vertex shader as an unsigned int and create the shader with glCreateShader:

```c++
unsigned int vertexShader;
vertexShader = glCreateShader(GL_VERTEX_SHADER);
```

We provide the type of shader we want to create as an argument to glCreateShader. Since we're creating a vertex shader we pass in GL_VERTEX_SHADER.

<h2>glCreateShader</h2><h3>Shaders</h3><p><p>
  The <code>glCreateShader</code> function creates an empty shader object behind the scenes and returns an unsigned reference ID to this shader object for further use. The function returns <code>0</code> if an error occurred creating the shader object.
</p>

<p>
  The parameters of <code>glCreateShader(GLenum shaderType)</code> are as follows:
  <ul>
    <li><code>shaderType</code>: Specifies the type of shader to be created. Can take one of the following values: <code>GL_COMPUTE_SHADER</code>, <code>GL_VERTEX_SHADER</code>, <code>GL_TESS_CONTROL_SHADER</code>, <code>GL_TESS_EVALUATION_SHADER</code>, <code>GL_GEOMETRY_SHADER</code> or <code>GL_FRAGMENT_SHADER</code>.</li>
  </ul>
</p>

</p>

Next we attach the shader source code to the shader object and compile the shader:

```c++
glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
glCompileShader(vertexShader);
```

The glShaderSource function takes the shader object to compile to as its first argument. The second argument specifies how many strings we're passing as source code, which is only one. The third parameter is the actual source code of the vertex shader and we can leave the 4th parameter to NULL.

<h2>glShaderSource</h2><h3>Shaders</h3><p><p>
  The <code>glShaderSource</code> function replaces the source code of a given shader object. Whenever the shader is then compiled, it compiled using the given source code.
</p>

<p>
  The parameters of <code>glShaderSource(GLuint shader, GLsizei count, const GLchar** string, const GLint *length)</code> are as follows:
  <ul>
    <li><code>shader</code>: Specifies the shader object whose source code is to be replaced. </li>
    <li><code>count</code>: Specifies the number of elements in the <code>string</code> array. </li>
    <li><code>string</code>: Specifies an array of pointers to strings containing the source code to be loaded into the shader. </li>
    <li><code>length</code>: Specifies an array of string lengths.  </li>
  </ul>
</p>

<h4>Example usage</h4>
<pre class="cpp"><code>
glShaderSource(vertexShader, 1, &vertexShaderSource, null);
glCompileShader(vertexShader);
</code></pre>
</p>

</br>

> [!NOTE]
> You probably want to check if compilation was successful after the call to glCompileShader and if not, what errors were found so you can fix those. Checking for compile-time errors is accomplished as follows:
>
> ```c++
> int  success;
> char infoLog[512];
> glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
> ```
>
> First we define an integer to indicate success and a storage container for the error messages (if any). Then we check if compilation was successful with glGetShaderiv. If compilation failed, we should retrieve the error message with glGetShaderInfoLog and print the error message.
> ```c++
> if(!success)
>{
>   glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
>    std::cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" << infoLog << std::endl;
>}
> ```

</br>
If no errors were detected while compiling the vertex shader it is now compiled.

# Fragment shader
The fragment shader is the second and final shader we're going to create for rendering a triangle. The fragment shader is all about calculating the color output of your pixels. To keep things simple the fragment shader will always output an orange-ish color.

</br>

> [!NOTE]
> Colors in computer graphics are represented as an array of 4 values: the red, green, blue and alpha (opacity) component, commonly abbreviated to RGBA. When defining a color in OpenGL or GLSL we set the strength of each component to a value between 0.0 and 1.0. If, for example, we would set red to 1.0 and green to 1.0 we would get a mixture of both colors and get the color yellow. Given those 3 color components we can generate over 16 million different colors!

</br>

```c++
#version 330 core
out vec4 FragColor;

void main()
{
    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);
} 
```

The fragment shader only requires one output variable and that is a vector of size 4 that defines the final color output that we should calculate ourselves. We can declare output values with the out keyword, that we here promptly named FragColor. Next we simply assign a vec4 to the color output as an orange color with an alpha value of 1.0 (1.0 being completely opaque).

The process for compiling a fragment shader is similar to the vertex shader, although this time we use the GL_FRAGMENT_SHADER constant as the shader type:

```c++
unsigned int fragmentShader;
fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
glCompileShader(fragmentShader);
```
Both the shaders are now compiled and the only thing left to do is link both shader objects into a shader program that we can use for rendering. Make sure to check for compile errors here as well!

<h2>glCreateShader</h2><h3>Shaders</h3><p><p>
  The <code>glCreateShader</code> function creates an empty shader object behind the scenes and returns an unsigned reference ID to this shader object for further use. The function returns <code>0</code> if an error occurred creating the shader object.
</p>

<p>
  The parameters of <code>glCreateShader(GLenum shaderType)</code> are as follows:
  <ul>
    <li><code>shaderType</code>: Specifies the type of shader to be created. Can take one of the following values: <code>GL_COMPUTE_SHADER</code>, <code>GL_VERTEX_SHADER</code>, <code>GL_TESS_CONTROL_SHADER</code>, <code>GL_TESS_EVALUATION_SHADER</code>, <code>GL_GEOMETRY_SHADER</code> or <code>GL_FRAGMENT_SHADER</code>.</li>
  </ul>
</p>

</p>
<h2>glShaderSource</h2><h3>Shaders</h3><p><p>
  The <code>glShaderSource</code> function replaces the source code of a given shader object. Whenever the shader is then compiled, it compiled using the given source code.
</p>

<p>
  The parameters of <code>glShaderSource(GLuint shader, GLsizei count, const GLchar** string, const GLint *length)</code> are as follows:
  <ul>
    <li><code>shader</code>: Specifies the shader object whose source code is to be replaced. </li>
    <li><code>count</code>: Specifies the number of elements in the <code>string</code> array. </li>
    <li><code>string</code>: Specifies an array of pointers to strings containing the source code to be loaded into the shader. </li>
    <li><code>length</code>: Specifies an array of string lengths.  </li>
  </ul>
</p>

<h4>Example usage</h4>
<pre class="cpp"><code>
glShaderSource(vertexShader, 1, &vertexShaderSource, null);
glCompileShader(vertexShader);
</code></pre>
</p>
<h2>glCompileShader</h2><h3>Shaders</h3><p><p>
  The function <code>glCompileShader</code> compiles the given shader object with the attached source of the shader object. To check if compilation fails and then retrieve the logs the functions <code>glGetShaderiv</code> and <code>glGetShaderInfoLog</code> are of use.
</p>

<p>
  The parameters of <code>glCompileShader(GLuint shader)</code> are as follows:
  <ul>
    <li><code>shader</code>: Specifies the shader object to be compiled.</li>
  </ul>
</p>
</p>

# Shader program
A shader program object is the final linked version of multiple shaders combined. To use the recently compiled shaders we have to link them to a shader program object and then activate this shader program when rendering objects. The activated shader program's shaders will be used when we issue render calls.

When linking the shaders into a program it links the outputs of each shader to the inputs of the next shader. This is also where you'll get linking errors if your outputs and inputs do not match.

Creating a program object is easy:

```c++
unsigned int shaderProgram;
shaderProgram = glCreateProgram();
```
The glCreateProgram function creates a program and returns the ID reference to the newly created program object. Now we need to attach the previously compiled shaders to the program object and then link them with glLinkProgram:

<h2>glCreateProgram</h2><h3>Shaders</h3><p><p>
  The <code>glCreateProgram</code> function creates a program object behind the scenes and returns an unsigned reference ID to this program object for further use. The function does not return negative IDs and the function returns <code>0</code> if an error occurred creating the program.
</p>

<p>
  <code>glCreateProgram</code> has no parameters.
</p>
</p>

```c++
glAttachShader(shaderProgram, vertexShader);
glAttachShader(shaderProgram, fragmentShader);
glLinkProgram(shaderProgram);
```
The code should be pretty self-explanatory, we attach the shaders to the program and link them via glLinkProgram.

<h2>glAttachShader</h2><h3>Shaders</h3><p><p>
  The <code>glAttachShader</code> function attaches a compiled shader object to a shader program. Any number of shader objects can be attached to a shader program as long as they have a different type.
</p>

<p>
  The parameters of <code>glAttachShader(GLuint program, GLuint shader)</code> are as follows:
  <ul>
    <li><code>program</code>: Specifies the program object to which a shader object will be attached. </li>
    <li><code>shader</code>: Specifies the shader object that is to be attached. </li>
  </ul>
</p>
</p>

<h2>glLinkProgram</h2><h3>Shaders</h3><p><p>
  The <code>glLinkProgram</code> function links all the attached shaders in one final shader program object. During the linking step, each output is matched to each input of the shaders and whenever something is not right linking fails.
</p>

<p>
  The parameters of <code>glLinkProgram(GLuint program)</code> are as follows:
  <ul>
    <li><code>program</code>: Specifies the program object to be linked. </li>
  </ul>
</p>
</p>
</br>

> [!NOTE]
> Just like shader compilation we can also check if linking a shader program failed and retrieve the corresponding log. However, instead of using ***glGetShaderiv*** and ***glGetShaderInfoLog*** we now use:
> ```c++
> glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
> if(!success) {
>    glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
>    ...
>}
> ```

</br>

<h2>glGetShaderiv</h2><h3>Shaders</h3><p><p>
  The function <code>glGetShaderiv</code> allows the developer to query a shader for information given an object parameter.
</p>

<p>
  The parameters of <code>glGetShaderiv(GLuint shader, GLenum pname, GLint *params)</code> are as follows:
  <ul>
    <li><code>shader</code>: Specifies the shader object to be queried. </li>
    <li><code>pname</code>: Specifies the object parameter. Accepted symbolic names are <code> GL_SHADER_TYPE</code>, <code>GL_DELETE_STATUS</code>, <code>GL_COMPILE_STATUS</code>, <code>GL_INFO_LOG_LENGTH</code>, <code>GL_SHADER_SOURCE_LENGTH</code>. </li>
    <li><code>params</code>: Returns the requested object parameter in the given <code>GLint</code> array. </li>
  </ul>
</p>

<h4>Example usage</h4>
<pre><code>
GLint success;
glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);
</code></pre>
</p>

<h2>glGetShaderInfoLog</h2><h3>Shaders</h3><p><p>
  The function <code>glGetShaderInfoLog</code> returns the information log for a shader object. The information log contains relevant information regarding a shader's compilation. Wherever a shader fails to compile it is advised to check the shader's info log for compile-time errors.
</p>

<p>
  The parameters of <code>glGetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei *length, GLchar *infoLog)</code> are as follows:
  <ul>
    <li><code>shader</code>: Specifies the shader object whose information log is to be queried. </li>
    <li><code>maxLength</code>: Specifies the size of the character buffer for storing the returned information log. </li>
    <li><code>length</code>: Returns the length of the string returned in <code>infoLog</code> (excluding the <code>null</code> terminator).</li>
    <li><code>infoLog</code>: Specifies an array of characters that is used to return the information log. </li>
  </ul>
</p>

<h4>Example usage</h4>
<pre><code>
GLchar infoLog[512];
glGetShaderInfoLog(vertex, 512, NULL, infoLog);
</code></pre>
</p>

<h2>glGetProgramiv</h2><h3>Shaders</h3><p><p>
  The function <code>glGetProgramiv</code> allows the developer to query a program for information given an object parameter.
</p>

<p>
  The parameters of <code>glGetProgramiv(GLuint program, GLenum pname, GLint *params)</code> are as follows:
  <ul>
    <li><code>program</code>: Specifies the program object to be queried. </li>
    <li><code>pname</code>: Specifies the program parameter. Typically <code>GL_LINK_STATUS</code> is queried. </li>
    <li><code>params</code>: Returns the requested object parameter in the given <code>GLint</code> array. </li>
  </ul>
</p>

<h4>Example usage</h4>
<pre><code>
GLint success;
glGetShaderiv(program, GL_LINK_STATUS, &amp;success);
</code></pre>
</p>

The result is a program object that we can activate by calling glUseProgram with the newly created program object as its argument:

```c++
glUseProgram(shaderProgram);
```

Every shader and rendering call after glUseProgram will now use this program object (and thus the shaders).

<h2>glUseProgram</h2><h3>Shaders</h3><p><p>
  The function <code>glUseProgram</code> sets the given program object as the current active shader program to use for subsequent drawing commands. If a value of <code>0</code> is provided, OpenGL will resort to its old drawing patterns.
</p>

<p>
  The parameters of <code>glUseProgram(GLuint program)</code> are as follows:
  <ul>
    <li><code>program</code>: The shader program object to use. This program object should be compiled and linked.</li>
  </ul>
</p>


<h4>Example usage</h4>
<pre class="cpp"><code>
glUseProgram(shaderProgram);
glBindVertexArray(VAO);
glDrawElements(GL_TRIANGLES, 64, GL_UNSIGNED_INT, 0)
glBindVertexArray(0);
</code></pre></p>

Oh yeah, and don't forget to delete the shader objects once we've linked them into the program object; we no longer need them anymore:

```c++
glDeleteShader(vertexShader);
glDeleteShader(fragmentShader);
```
<h2>glDeleteShader</h2><h3>Shaders</h3><p><p>
  The <code>glDeleteShader</code> function removes the given shader object, clearing all allocated memory that is no longer necessery and invalidated the name assosciated with the shader object. It is advised to do this after linking the shaders into a program; they're no longer needed after that.
</p>

<p>
  The parameters of <code>glDeleteShader(GLuint shader)</code> are as follows:
  <ul>
    <li><code>shader</code>: Specifies the shader object to be deleted. </li>
  </ul>
</p>
</p>

Right now we sent the input vertex data to the GPU and instructed the GPU how it should process the vertex data within a vertex and fragment shader. We're almost there, but not quite yet. OpenGL does not yet know how it should interpret the vertex data in memory and how it should connect the vertex data to the vertex shader's attributes. We'll be nice and tell OpenGL how to do that.

# Linking Vertex Attributes
The vertex shader allows us to specify any input we want in the form of vertex attributes and while this allows for great flexibility, it does mean we have to manually specify what part of our input data goes to which vertex attribute in the vertex shader. This means we have to specify how OpenGL should interpret the vertex data before rendering.

Our vertex buffer data is formatted as follows:

<img src="https://learnopengl.com/img/getting-started/vertex_attribute_pointer.png"/>

<ul>
    <li>The position data is stored as 32-bit (4 byte) floating point values.</li>
    <li>Each position is composed of 3 of those values.</li>
    <li>There is no space (or other values) between each set of 3 values. The values are <def>tightly packed</def> in the array.</li>
    <li>The first value in the data is at the beginning of the buffer.</li>
  </ul>

  <p>
   With this knowledge we can tell OpenGL how it should interpret the vertex data (per vertex attribute) using <fun><function id="30">glVertexAttribPointer</function></fun>:
</p>

```c++
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
```

The function ***glVertexAttribPointer*** has quite a few parameters so let's carefully walk through them:


<ul>
    <li>The first parameter specifies which vertex attribute we want to configure. Remember that we specified the location of the <var>position</var> vertex attribute in the vertex shader with <code>layout (location = 0)</code>. This sets the location of the vertex attribute to <code>0</code> and since we want to pass data to this vertex attribute, we pass in <code>0</code>.
    </li>
    <li>The next argument specifies the size of the vertex attribute. The vertex attribute is a <code>vec3</code> so it is composed of <code>3</code> values.</li>
    <li>The third argument specifies the type of the data which is <var>GL_FLOAT</var> (a <code>vec*</code> in GLSL consists of floating point values).</li>
    <li>The next argument specifies if we want the data to be normalized. If we're inputting integer data types (int, byte) and we've set this to <var>GL_TRUE</var>, the integer data is normalized to <code>0</code> (or <code>-1</code> for signed data) and <code>1</code> when converted to float. This is not relevant for us so we'll leave this at <var>GL_FALSE</var>.</li>
    <li>The fifth argument is known as the <def>stride</def> and tells us the space between consecutive vertex attributes. Since the next set of position data is located exactly 3 times the size of a <code>float</code> away we specify that value as the stride. Note that since we know that the array is tightly packed (there is no space between the next vertex attribute value) we could've also specified the stride as <code>0</code> to let OpenGL determine the stride (this only works when values are tightly packed). Whenever we have more vertex attributes we have to carefully define the spacing between each vertex attribute but we'll get to see more examples of that later on.</li>
    <li>The last parameter is of type <code>void*</code> and thus requires that weird cast. This is the <def>offset</def> of where the position data begins in the buffer. Since the position data is at the start of the data array this value is just <code>0</code>. We will explore this parameter in more detail later on</li>
  </ul>

<h2>glVertexAttribPointer</h2><h3>Shaders</h3><p><p>
  The function <code>glVertexAttribPointer</code> specifies how OpenGL should interpret the vertex buffer data whenever a drawing call is made. The interpretation specified is stored in the currently bound vertex array object saving us all quite some work.
</p>

<p>
  The parameters of <code>glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer)</code> are as follows:
  <ul>
    <li><code>index</code>: Specifies the index of the vertex attribute.</li>
    <li><code>size</code>: Specifies the number of components per vertex attribute. Must be 1, 2, 3, 4. </li>
    <li><code>type</code>: Specifies the data type of each component in the array. </li>
    <li><code>normalized</code>: Specifies whether data should be normalized (clamped to the range <code>-1</code> to <code>1</code> for signed values and <code>0</code> to <code>1</code> for unsigned values).</li>
    <li><code>stride</code>: Specifies the byte offset between consecutive vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array </li>
    <li><code>pointer</code>: Specifies an offset of the first component of the first vertex attribute in the array. </li>
  </ul>
</p>

<h4>Example usage</h4>
<pre class="cpp"><code>
GLfloat data[] = {
  // Position  // Color           // TexCoords
  1.0f, 0.0f,  0.5f, 0.5f, 0.5f, 0.0f, 0.5f,
  0.0f, 1.0f,  0.2f, 0.8f, 0.0f, 0.0f, 1.0f
};
glEnableVertexAttribArray(0);
glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 
  	7 * sizeof(GLfloat), (GLvoid*)0);
glEnableVertexAttribArray(1);
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 
  	7 * sizeof(GLfloat), (GLvoid*)(2 * sizeof(GLfloat)));
glEnableVertexAttribArray(2);
glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 
  	7 * sizeof(GLfloat), (GLvoid*)(5 * sizeof(GLfloat)));
</code></pre></p>

> [!NOTE]
> Each vertex attribute takes its data from memory managed by a VBO and which VBO it takes its data from (you can have multiple VBOs) is determined by the VBO currently bound to GL_ARRAY_BUFFER when calling glVertexAttribPointer. Since the previously defined VBO is still bound before calling glVertexAttribPointer vertex attribute 0 is now associated with its vertex data.

Now that we specified how OpenGL should interpret the vertex data we should also enable the vertex attribute with glEnableVertexAttribArray giving the vertex attribute location as its argument; vertex attributes are disabled by default. From that point on we have everything set up: we initialized the vertex data in a buffer using a vertex buffer object, set up a vertex and fragment shader and told OpenGL how to link the vertex data to the vertex shader's vertex attributes. Drawing an object in OpenGL would now look something like this:

<h2>glEnableVertexAttribArray</h2><h3>Shaders</h3><p><p>
  The function <code>glEnableVertexAttribArray</code> enables a generic vertex attribute. A vertex attribute can be disabled by calling <code>glDisableVertexAttribArray</code>.
</p>

<p>
  The parameters of <code>glEnableVertexAttribArray(GLuint index)</code> are as follows:
  <ul>
    <li><code>index</code>: Specifies the index of the vertex attribute to be enabled.</li>
  </ul>
</p></p>

```c++
// 0. copy our vertices array in a buffer for OpenGL to use
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
// 1. then set the vertex attributes pointers
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);  
// 2. use our shader program when we want to render an object
glUseProgram(shaderProgram);
// 3. now draw the object 
someOpenGLFunctionThatDrawsOurTriangle();   
```

We have to repeat this process every time we want to draw an object. It may not look like that much, but imagine if we have over 5 vertex attributes and perhaps 100s of different objects (which is not uncommon). Binding the appropriate buffer objects and configuring all vertex attributes for each of those objects quickly becomes a cumbersome process. What if there was some way we could store all these state configurations into an object and simply bind this object to restore its state?

# Vertex Array Object
A vertex array object (also known as VAO) can be bound just like a vertex buffer object and any subsequent vertex attribute calls from that point on will be stored inside the VAO. This has the advantage that when configuring vertex attribute pointers you only have to make those calls once and whenever we want to draw the object, we can just bind the corresponding VAO. This makes switching between different vertex data and attribute configurations as easy as binding a different VAO. All the state we just set is stored inside the VAO.

> [!CAUTION]
> Core OpenGL requires that we use a VAO so it knows what to do with our vertex inputs. If we fail to bind a VAO, OpenGL will most likely refuse to draw anything.

</br>
A vertex array object stores the following:
<ul>
  <li>Calls to <fun><function id="29"><function id="60">glEnable</function>VertexAttribArray</function></fun> or <fun>glDisableVertexAttribArray</fun>.</li>
  <li>Vertex attribute configurations via <fun><function id="30">glVertexAttribPointer</function></fun>.</li>
  <li>Vertex buffer objects associated with vertex attributes by calls to <fun><function id="30">glVertexAttribPointer</function></fun>.</li>
</ul>

<img src="https://learnopengl.com/img/getting-started/vertex_array_objects.png"/>

The process to generate a VAO looks similar to that of a VBO:

```c++
unsigned int VAO;
glGenVertexArrays(1, &VAO);
```

<h2>glGenVertexArrays</h2><h3>Shaders</h3><p><p>
  The function <code>glGenVertexArrays</code> function generates one or multiple vertex array object(s). Vertex array objects are instantiated behind the scenes and reference ID(s) are returned to the user to access those vertex array objects. The type of the returned IDs is <code>GLuint</code>.
</p>
<p>
  The parameters of <code>glGenVertexArrays(GLsizei n, GLuint* arrays)</code> are as follows:
  <ul>
    <li><code>n</code>: Specifies how many vertex array objects you would like to generate. <code>glGenVertexArrays</code> will return this many buffer IDs to the target <code>arrays</code> array.</li>
    <li><code>arrays</code>: Specifies an array in which the generated vertex array object IDs are stored. </li>
  </ul>
</p>

<h4>Example usage</h4>
<pre class="cpp"><code>
GLuint vaos[5]; // Can hold the id of 5 vertex array objects
glGenVertexArrays(5, &vaos); // Generates 5 vertex array object ids  
</code></pre>
</p>

To use a VAO all you have to do is bind the VAO using glBindVertexArray. From that point on we should bind/configure the corresponding VBO(s) and attribute pointer(s) and then unbind the VAO for later use. As soon as we want to draw an object, we simply bind the VAO with the preferred settings before drawing the object and that is it. In code this would look a bit like this:

```c++
// ..:: Initialization code (done once (unless your object frequently changes)) :: ..
// 1. bind Vertex Array Object
glBindVertexArray(VAO);
// 2. copy our vertices array in a buffer for OpenGL to use
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
// 3. then set our vertex attributes pointers
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);  

  
[...]

// ..:: Drawing code (in render loop) :: ..
// 4. draw the object
glUseProgram(shaderProgram);
glBindVertexArray(VAO);
someOpenGLFunctionThatDrawsOurTriangle();
```

And that is it! Everything we did the last few million pages led up to this moment, a VAO that stores our vertex attribute configuration and which VBO to use. Usually when you have multiple objects you want to draw, you first generate/configure all the VAOs (and thus the required VBO and attribute pointers) and store those for later use. The moment we want to draw one of our objects, we take the corresponding VAO, bind it, then draw the object and unbind the VAO again.

<h2>glBindVertexArray</h2><h3>Shaders</h3><p><p>
  The function <code>glBindVertexArray</code> binds a <em>vertex array object</em>. Any subsequent <code>VBO</code>, <code>EBO</code>, <code>glVertexAttribPointer</code> and <code>glEnableVertexAttribArray</code> calls will be stored inside the VAO currently bound.
</p>

<p>
  The parameters of <code>glBindVertexArray(GLuint array)</code> are as follows:
  <ul>
    <li><code>array</code>: The VAO to bind.</li>
  </ul>
</p></p>

# The triangle we've all been waiting for
To draw our objects of choice, OpenGL provides us with the glDrawArrays function that draws primitives using the currently active shader, the previously defined vertex attribute configuration and with the VBO's vertex data (indirectly bound via the VAO).

```c++
glUseProgram(shaderProgram);
glBindVertexArray(VAO);
glDrawArrays(GL_TRIANGLES, 0, 3);
```

The glDrawArrays function takes as its first argument the OpenGL primitive type we would like to draw. Since I said at the start we wanted to draw a triangle, and I don't like lying to you, we pass in GL_TRIANGLES. The second argument specifies the starting index of the vertex array we'd like to draw; we just leave this at 0. The last argument specifies how many vertices we want to draw, which is 3 (we only render 1 triangle from our data, which is exactly 3 vertices long).

<h2>glDrawArrays</h2><h3>Drawing</h3><p><p>
  The function <code>glDrawArrays</code> draws <code>count</code> vertices found in the currently bound vertex buffer object (or indirectly via a vertex array object). 
</p>

<p>
  The parameters of <code>glDrawArrays(GLenum mode, GLint first, GLsizei count)</code> are as follows:
  <ul>
    <li><code>mode</code>: Specifies the kind of primitive to render. Can take the following values: <code>GL_POINTS</code>, <code>GL_LINE_STRIP</code>, <code>GL_LINE_LOOP</code>, <code>GL_LINES</code>, <code>GL_TRIANGLE_STRIP</code>, <code>GL_TRIANGLE_FAN</code>, <code>GL_TRIANGLES</code>, <code>GL_QUAD_STRIP</code>, <code>GL_QUADS</code>, and <code>GL_POLYGON</code>.</li>
    <li><code>first</code>: Specifies the starting index in the enabled arrays. </li>
    <li><code>count</code>: Specifies the number of vertices to render. </li>
  </ul>
</p>

<h4>Example usage</h4>
<pre class="cpp"><code>
glUseProgram(shaderProgram);
glBindVertexArray(VAO);
glDrawArrays(GL_TRIANGLES, 0, 3);
glBindVertexArray(0);  
</code></pre></p>

ow try to compile the code and work your way backwards if any errors popped up. As soon as your application compiles, you should see the following result:

<img src="https://learnopengl.com/img/getting-started/hellotriangle.png">

The source code for the complete program can be found:
```c++
#include <glad/glad.h>
#include <GLFW/glfw3.h>

#include <iostream>

void framebuffer_size_callback(GLFWwindow* window, int width, int height);
void processInput(GLFWwindow *window);

// settings
const unsigned int SCR_WIDTH = 800;
const unsigned int SCR_HEIGHT = 600;

const char *vertexShaderSource = "#version 330 core\n"
    "layout (location = 0) in vec3 aPos;\n"
    "void main()\n"
    "{\n"
    "   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
    "}\0";
const char *fragmentShaderSource = "#version 330 core\n"
    "out vec4 FragColor;\n"
    "void main()\n"
    "{\n"
    "   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"
    "}\n\0";

int main()
{
    // glfw: initialize and configure
    // ------------------------------
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

#ifdef __APPLE__
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
#endif

    // glfw window creation
    // --------------------
    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "LearnOpenGL", NULL, NULL);
    if (window == NULL)
    {
        std::cout << "Failed to create GLFW window" << std::endl;
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

    // glad: load all OpenGL function pointers
    // ---------------------------------------
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
    {
        std::cout << "Failed to initialize GLAD" << std::endl;
        return -1;
    }


    // build and compile our shader program
    // ------------------------------------
    // vertex shader
    unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
    glCompileShader(vertexShader);
    // check for shader compile errors
    int success;
    char infoLog[512];
    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
    if (!success)
    {
        glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
        std::cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" << infoLog << std::endl;
    }
    // fragment shader
    unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
    glCompileShader(fragmentShader);
    // check for shader compile errors
    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);
    if (!success)
    {
        glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);
        std::cout << "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" << infoLog << std::endl;
    }
    // link shaders
    unsigned int shaderProgram = glCreateProgram();
    glAttachShader(shaderProgram, vertexShader);
    glAttachShader(shaderProgram, fragmentShader);
    glLinkProgram(shaderProgram);
    // check for linking errors
    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
    if (!success) {
        glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
        std::cout << "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" << infoLog << std::endl;
    }
    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);

    // set up vertex data (and buffer(s)) and configure vertex attributes
    // ------------------------------------------------------------------
    float vertices[] = {
        -0.5f, -0.5f, 0.0f, // left  
         0.5f, -0.5f, 0.0f, // right 
         0.0f,  0.5f, 0.0f  // top   
    }; 

    unsigned int VBO, VAO;
    glGenVertexArrays(1, &VAO);
    glGenBuffers(1, &VBO);
    // bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).
    glBindVertexArray(VAO);

    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);

    // note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute's bound vertex buffer object so afterwards we can safely unbind
    glBindBuffer(GL_ARRAY_BUFFER, 0); 

    // You can unbind the VAO afterwards so other VAO calls won't accidentally modify this VAO, but this rarely happens. Modifying other
    // VAOs requires a call to glBindVertexArray anyways so we generally don't unbind VAOs (nor VBOs) when it's not directly necessary.
    glBindVertexArray(0); 


    // uncomment this call to draw in wireframe polygons.
    //glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);

    // render loop
    // -----------
    while (!glfwWindowShouldClose(window))
    {
        // input
        // -----
        processInput(window);

        // render
        // ------
        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);

        // draw our first triangle
        glUseProgram(shaderProgram);
        glBindVertexArray(VAO); // seeing as we only have a single VAO there's no need to bind it every time, but we'll do so to keep things a bit more organized
        glDrawArrays(GL_TRIANGLES, 0, 3);
        // glBindVertexArray(0); // no need to unbind it every time 
 
        // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)
        // -------------------------------------------------------------------------------
        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    // optional: de-allocate all resources once they've outlived their purpose:
    // ------------------------------------------------------------------------
    glDeleteVertexArrays(1, &VAO);
    glDeleteBuffers(1, &VBO);
    glDeleteProgram(shaderProgram);

    // glfw: terminate, clearing all previously allocated GLFW resources.
    // ------------------------------------------------------------------
    glfwTerminate();
    return 0;
}

// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly
// ---------------------------------------------------------------------------------------------------------
void processInput(GLFWwindow *window)
{
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
        glfwSetWindowShouldClose(window, true);
}

// glfw: whenever the window size changed (by OS or user resize) this callback function executes
// ---------------------------------------------------------------------------------------------
void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
    // make sure the viewport matches the new window dimensions; note that width and 
    // height will be significantly larger than specified on retina displays.
    glViewport(0, 0, width, height);
}
```



















